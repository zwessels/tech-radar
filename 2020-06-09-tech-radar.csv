name,ring,quadrant,isNew,description
Applying product management to internal platforms,Adopt,Techniques,FALSE,"<p>More and more companies are building internal platforms to roll out new digital solutions quickly and efficiently. Companies that succeed with this strategy are <strong>applying product management to internal platforms</strong>. This means establishing empathy with internal consumers (the development teams) and collaborating with them on the design. Platform product managers create roadmaps and ensure the platform delivers value to the business and enhances the developer experience. Unfortunately, we're also seeing less successful approaches, where teams create a platform in the void, based on unverified assumptions and without internal customers. These platforms, often despite aggressive internal tactics, end up being underutilized and a drain on the organization's delivery capability. As usual, good product management is all about building products that consumers love.</p>"
Continuous delivery for machine learning (CD4ML),Trial,Techniques,FALSE,"<p>Applying machine learning to make the business applications and services intelligent is more than just training models and serving them. It requires implementing end-to-end and continuously repeatable cycles of training, testing, deploying, monitoring and operating the models. <strong><a href=""https://martinfowler.com/articles/cd4ml.html"">Continuous delivery for machine learning (CD4ML)</a></strong> is a technique that enables reliable end-to-end cycles of development, deploying and monitoring machine learning models. The underpinning technology stack to enable CD4ML includes tooling for accessing and discovering data, version control of artefacts (such as data, model and code), continuous delivery pipelines, automated environment provisioning for various deployments and experiments, model performance assessment and tracking, and model operational observability. Companies can choose their own tool set depending on their existing tech stack. CD4ML emphasizes automation and removing manual handoffs. CD4ML is our de facto approach for developing ML models.</p>"
Data mesh,Assess,Techniques,FALSE,"<p><strong><a href=""https://martinfowler.com/articles/data-monolith-to-mesh.html"">Data mesh</a></strong> is an architectural and organizational paradigm that challenges the age-old assumption that we must centralize big analytical data to use it, have data all in one place or be managed by a centralized data team to deliver value. Data mesh claims that for big data to fuel innovation, its ownership must be federated among domain data owners who are accountable for providing their data as products (with the support of a self-serve data platform to abstract the technical complexity involved in serving data products);  it must also adopt a new form of federated governance through automation to enable interoperability of domain-oriented data products. Decentralization, along with interoperability and focus on the experience of data consumers, are key to the democratization of innovation using data.</p>"
Cloud lift and shift,Hold,Techniques,FALSE,"<p>It is rather curious, that after over a decade of industry experience with cloud migration, we still feel it's necessary to call out <strong>cloud lift and shift</strong>; a practice that views cloud simply as a hosting solution, resulting in the replication of an existing architecture, security practices and IT operational models in the cloud. This fails to realize the cloud's promises of agility and digital innovation. A cloud migration requires intentional change across multiple axes toward a cloud-native state, and depending on the unique migration circumstances, each organization might end up somewhere on the spectrum from cloud lift and shift to cloud native. Systems architecture, for example, is one of the pillars of delivery agility and often requires change. The temptation to simply <a href=""https://cloud.google.com/migrate/anthos/docs/anthos-migrate-benefits"">lift and shift existing systems as containers</a> to the cloud can be strong. While this tactic can speed up cloud migration, it falls short when it comes to creating agility and delivering features and value. Enterprise security in the cloud is fundamentally different from traditional perimeter-based security through firewalls and zoning, and it demands a journey toward <a href=""/radar/techniques/zero-trust-architecture-zta"">zero trust architecture</a>. The IT operating model too has to be reformed to safely provide cloud services through self-serve automated platforms and empower teams to take more of the operational responsibility and gain autonomy. Last but not least, organizations must build a foundation to enable continuous change, such as creating pipelines with continuous testing of applications and infrastructure as a part of the migration. These will help the migration process, result in a more robust and well-factored system and give organizations a way to continue to evolve and improve their systems.</p>"
Istio,Adopt,Platforms,FALSE,"<p>If you're building and operating a scaled <a href=""https://martinfowler.com/articles/microservices.html"">microservices</a> architecture and have embraced <a href=""/radar/platforms/kubernetes"">Kubernetes</a>, adopting <a href=""/radar/techniques/service-mesh"">service mesh</a> to manage all cross-cutting aspects of running the architecture is a default position. Among various implementations of service mesh, <strong><a href=""https://istio.io"">Istio</a></strong> has gained majority adoption. It has a rich feature set, including service discovery, traffic management, service-to-service and origin-to-service security, observability (including telemetry and distributed tracing), rolling releases and resiliency. Its user experience has been improved in its latest releases, because of its ease of installation and control panel architecture. Istio has lowered the bar for implementing large-scale microservices with operational quality for many of our clients, while admitting that operating your own Istio and Kubernetes instances requires adequate knowledge and internal resources which is not for the fainthearted.</p>"
Argo CD,Trial,Platforms,TRUE,"<p>Without making a judgment of the GitOps technique, we'd like to talk about <strong><a href=""https://argoproj.github.io/argo-cd/"">Argo CD</a></strong> within the scope of deploying and monitoring applications in <a href=""/radar/platforms/kubernetes"">Kubernetes</a> environments. Based on its ability to automate the deployment of the desired application state in the specified target environments in Kubernetes and our good experience with troubleshooting failed deployments, verifying logs and monitoring deployment status, we recommend you give Argo CD a try. You can even see graphically what is going on in the cluster, how a change is propagated and how pods are created and destroyed in real time.</p>"
Anthos,Assess,Platforms,TRUE,"<p>We see a shift from accidental hybrid or whole-of-estate cloud migration plans to intentional and sophisticated hybrid, poly or portable cloud strategies, where organizations apply multidimensional principles to establish and execute their cloud strategy: where to host their various data and functional assets based on risk, ability to control and performance profiles; how to utilize their on-premise infrastructure investments while reducing the cost of operations; and how to take advantage of multiple cloud providers and their unique differentiated services without creating complexity and friction for users building and operating applications.</p>"
Node overload,Hold,Platforms,TRUE,"<p>Technologies, especially wildly popular ones, have a tendency to be overused. What we're seeing at the moment is <strong>Node overload</strong>, a tendency to use Node.js indiscriminately or for the wrong reasons. Among these, two stand out in our opinion. Firstly, we frequently hear that Node should be used so that all programming can be done in one programming language. Our view remains that <a href=""/radar/techniques/polyglot-programming"">polyglot programming</a> is a better approach, and this still goes <a href=""/radar/languages-and-frameworks/javascript-as-a-first-class-language"">both ways</a>. Secondly, we often hear teams cite performance as a reason to choose Node.js. Although there are myriads of more or less sensible benchmarks, this perception is rooted in history. When Node.js became popular, it was the first major framework to embrace a nonblocking programming model which made it very efficient for IO-heavy tasks. (We mentioned this in our write-up of Node.js in 2012.) Due to its single-threaded nature, Node.js was never a good choice for compute-heavy workloads, though, and now that capable nonblocking frameworks also exist on other platforms — some with elegant, modern APIs — performance is no longer a reason to choose Node.js.</p>"
Cypress,Adopt,Tools,FALSE,"<p><strong><a href=""http://www.cypress.io/"">Cypress</a></strong> is still a favorite among our teams where developers manage end-to-end tests themselves, as part of a healthy <a href=""https://martinfowler.com/articles/practical-test-pyramid.html#End-to-endTests"">test pyramid</a>, of course. We decided to call it out again in this Radar because recent versions of Cypress have added <a href=""https://cypress.io/blog/2020/02/06/introducing-firefox-and-edge-support-in-cypress-4-0/"">support for Firefox</a>, and we strongly suggest testing on multiple browsers. The dominance of Chrome and Chromium-based browsers has led to a worrying trend of teams seemingly only testing with Chrome which can lead to <a href=""https://twitter.com/mike_conley/status/1245797292453609478"">nasty surprises</a>.</p>"
Dojo,Trial,Tools,TRUE,"<p>A few years ago, Docker — and containers in general — radically changed how we think about packaging, deploying and running our applications. But despite this improvement in production, developers still spend a lot of time setting up development environments and regularly run into ""but it works on my machine"" style problems. <strong><a href=""https://github.com/kudulab/dojo"">Dojo</a></strong> aims to fix this by creating standard development environments, versioned and released as Docker images. Several of our teams use Dojo to streamline developing, testing and building code from local development through production pipelines.</p>"
Apache Superset,Assess,Tools,TRUE,"<p><strong><a href=""https://superset.apache.org/"">Apache Superset</a></strong> is a great business intelligence (BI) tool for data exploration and visualization to work with large data lake and data warehouse setups. It works, for example, with <a href=""/radar/platforms/presto"">Presto</a>, <a href=""https://aws.amazon.com/athena/"">Amazon Athena</a> and <a href=""https://aws.amazon.com/redshift/"">Amazon Redshift</a> and can be nicely integrated with enterprise authentication. Moreover, you don't have to be a data engineer to use it; it’s meant to benefit all engineers exploring data in their everyday work. It's worth pointing out that Apache Superset is currently undergoing incubation at the Apache Software Foundation (ASF), meaning it's not yet fully endorsed by ASF.</p>"
React Hooks,Adopt,languages-and-frameworks,FALSE,"<p><strong><a href=""https://reactjs.org/docs/hooks-intro.html"">React Hooks</a></strong> have introduced a new approach to managing stateful logic; given React components have always been closer to functions than classes, Hooks have embraced this and brought state to the functions, instead of taking function as methods to the state with classes. Based on our experience, Hooks improve reuse of functionality among components and code readability. Given Hooks’ testability improvements, using <a href=""https://reactjs.org/docs/test-renderer.html"">React Test Renderer</a> and <a href=""/radar/languages-and-frameworks/react-testing-library"">React Testing Library</a>, and their growing community support, we consider them our approach of choice.</p>"
CSS-in-JS,Trial,languages-and-frameworks,FALSE,"<p>Since we first mentioned <strong>CSS-in-JS</strong> as an emerging technique in 2017, it has become much more popular, a trend we also see in our work. With some solid production experience under our belts, we can now recommend CSS-in-JS as a technique to trial. A good starting point is the <a href=""/radar/languages-and-frameworks/styled-components"">styled components</a> framework, which we mentioned in our previous Radar. Next to all the positives, though, there usually is a downside when using CSS-in-JS: the calculation of styles at runtime can cause a <a href=""https://calendar.perfplanet.com/2019/the-unseen-performance-costs-of-css-in-js-in-react-apps/"">noticeable lag for end users</a>. With <a href=""https://linaria.now.sh/"">Linaria</a> we're now seeing a new class of frameworks that were created with this issue in mind. Linaria employs a number of techniques to shift most of the performance overhead to build time. Alas, this does come with its own set of trade-offs, most notably a lack of dynamic style support in IE11.</p>"
SwiftUI,Trial,languages-and-frameworks,FALSE,"<p>Apple has taken a big step forward with their new <strong><a href=""https://developer.apple.com/xcode/swiftui/"">SwiftUI</a></strong> framework for implementing user interfaces on the macOS and iOS platforms. We like that SwiftUI moves beyond the somewhat kludgy relationship between Interface Builder and Xcode and adopts a coherent, declarative and code-centric approach. You can now view your code and the resulting visual interface side by side in Xcode 11, making for a much better developer experience. The SwiftUI framework also draws inspiration from the <a href=""/radar/languages-and-frameworks/react-js"">React.js</a> world that has dominated web development in recent years. Immutable values in view models and an asynchronous update mechanism make for a unified reactive programming model. This gives developers an entirely native alternative to similar reactive frameworks such as <a href=""/radar/languages-and-frameworks/react-native"">React Native</a> or <a href=""/radar/languages-and-frameworks/flutter"">Flutter</a>. SwiftUI definitely represents the future of Apple UI development, and although new, it has shown its benefits. We've been having great experience with it — and its shallow learning curve. It's worth noting that you should know your customer's use case before jumping into using SwiftUI, given that it doesn't support iOS 12 or below.</p>"
Clinic.js Bubbleprof,Assess,languages-and-frameworks,TRUE,"<p>With the aim of improving performance in our code, profiling tools are very useful to identify bottlenecks or delays in code which are hard to identify, especially in asynchronous operations. <strong><a href=""https://clinicjs.org/bubbleprof/"">Clinic.js Bubbleprof</a></strong> represents visually the async operations in Node.js processes, drawing a map of delays in the application's flow. We like this tool because it helps developers to easily identify and prioritize what to improve in the code.</p>"
Deequ,Assess,languages-and-frameworks,TRUE,"<p>There are still some tool gaps when applying good software engineering practices in data engineering. Attempting to automate data quality checks between different steps in a data pipeline, one of our teams was surprised when they found only a few tools in this space. They settled on <strong><a href=""https://github.com/awslabs/deequ"">Deequ</a></strong>, a library for writing tests that resemble unit tests for data sets. Deequ is built on top of <a href=""/radar/platforms/apache-spark"">Apache Spark</a>, and even though it's published by AWS Labs it can be used in environments other than <a href=""/radar/platforms/aws"">AWS</a>.</p>"
XState,Assess,languages-and-frameworks,TRUE,"<p>We've featured several state management libraries in the Radar before, but <strong><a href=""https://xstate.js.org/docs/"">XState</a></strong> takes a slightly different approach. It's a simple JavaScript and <a href=""/radar/languages-and-frameworks/typescript"">TypeScript</a> framework for creating finite state machines and visualizing them as state charts. It integrates with the more popular reactive JavaScript frameworks (<a href=""/radar/languages-and-frameworks/vue-js"">Vue.js</a>, <a href=""/radar/languages-and-frameworks/ember-js"">Ember.js</a>, <a href=""/radar/languages-and-frameworks/react-js"">React.js</a> and <a href=""https://rxjs.dev/"">RxJS</a>) and is based on the W3C standard for finite state machines. Another notable feature is the serialization of machine definitions. One thing that we've found helpful when creating finite state machines in other contexts (particularly when writing game logic) is the ability to visualize states and their possible transitions; we like the fact that it's really easy to do this with XState's <a href=""https://xstate.js.org/viz/"">visualizer</a>.</p>"
Enzyme,Hold,languages-and-frameworks,FALSE,"<p>We don't always move deprecated tools to Hold in the Radar, but our teams feel strongly that <strong><a href=""http://airbnb.io/enzyme/"">Enzyme</a></strong> has been replaced for unit testing <a href=""/radar/languages-and-frameworks/react-js"">React</a> UI components by <a href=""https://testing-library.com/docs/intro"">React Testing Library</a>. Teams using Enzyme have found that its focus on testing component internals leads to brittle, unmaintainable tests.</p>"
